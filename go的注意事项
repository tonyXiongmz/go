1、go的格式化时间，很恶心，数字必须匹配
time.Now().Format("2006-01-02 15:04:05")
form:"birthday" time_format:"2006-01-02"

2、gin输出自定义端口必须加冒号
r.Run(":8084")

3、多语言翻译验证必须使用validator.v9版本

4、不用的加载包前面加下划线避免报错，有忽略的作用

5、真实环境中，go的运行必须先编译，go build xxx.go 生成xxx.exe文件
go run  xxx.go是一种快捷方式，测试时使用
两者区别是window下exe文件，linux是可执行文件，在无go开发环境下也能运行，包含了文件比较多，二进制

6、GO程序的执行入口是main函数
7、严格区分大小写
8、每个语句后面不需要带分号
9、申明的变量必须使用，否则报错
10、转义字符\n，转义符之后的字符会替换掉输出语句最前面的字符
11、加号的使用，两个都是int型是运算符，都是string是拼接符,string字符较长时换行拼接要把加号放在行尾
12、存储汉字用rune类型，unicode
13、整数的区间范围
有符号的整数
int8 -2^7--2^7-1  一个字节
int16 -2^15--2^15-1 两个字节
int32  -2^31--2^31-1 三个字节
int64
无符号的整数
uint8 0--2^8-1
uint16 0--2^16-1
uint32 0--2^32-1
uint64 0--2^64-1

14、float数据类型，float64比float32更精准
15、bool类型主要用在逻辑运算中，默认值为false
16、string，汉字显示Unicode值用%d,Unicode显示汉字用%c
17、数据类型转换，显示类型转换，float32(i),int64(i)
18、数据运算当心超出范围，数据溢出
19、数据类型转string,fmt.Sprint("%d",val),这是转换函数，%f,%c,%t
strconv.FormatFloat(num,'f',10,64)
strconv.FormatInt(num,10)

strconv.Itoa(num)
20、字符串转其他类型,如果是混合字符串类型会转成string,值为0，false
strconv.ParseInt(str,10,64)
strconv.ParseFloat(str,64)
strconv.ParseBool(str)
 21、变量、常量、函数名如果是小写开头只能在本包下使用，大写可以全局使用
22、golang中有25个保留关键字和36个预定义标识符



--------------运算符-------------
算数运算符的结果取决于首数值，如果是整数结果也会是整数，不保留小数点后的数字，结果的符号取决于首值的符号
golang中只有i++,i--
逻辑表达式，短路与--如果第一个判断为false则第一个判断不继续执行，短路或--如果第一个判断为true则第二个判断不继续执行
赋值运算符：左侧只能是变量，右侧可以是变量、函数、常量、表达式
运算符的优先级，单目、赋值是从右向左
1）括号 ++ --
2）单目运算符
3）算术运算符
4）移位运算符
5）关系运算符
6）位运算符
7）逻辑运算符
8）赋值运算符
9）逗号


------进制转换-----
二进制转换十进制  ---- 将对应位数的数字*2（位数-1）方
八进制转换十进制  ---- 将对应位数的数字*8（位数-1）方
十六进制转换十进制 --- 将对应位数的数字*16（位数-1）方

十进制转二进制  --- 将十进制的数除以2，商一直除2，得到的余数倒过来
十进制转八进制  --- 将十进制的数除以8，商一直除8，得到的余数倒过来
十进制转十六进制  --- 将十进制的数除以16，商一直除16，得到的余数倒过来

二进制转八进制  --- 每三位一组转换成对应的十进制拼接在一起
二进制转十六进制 --- 每四位一组转换成对应的十进制数字拼接一起

八进制转二进制  --- 将八进制数从低位转换成3位二进制数
十六进制转二进制 ---将十六进制数从低位转换成4位二进制数


----------原码、补码、反码---------
1）对于有符号的，二进制最高位是符号位，0表示正数，1表示负数
2）正数的原码、反码、补码都一样
3）负数的反码是原符号位不变，其他位取反
4）负数的补码是他的反码加1
5）0的反码补码都是0
6）计算机的运算都是以反码运行的

正负数的位运算需要转换成补码运行，然后再转换为反码、原码得出结果


--------控制语句----------
1、if判断语句中，条件必须是判断表达式，不能是赋值
2、else和大括号同行，不能换行

------循环语句--------
for遍历字符串 len(str)//按照字符串遍历
range str //按照字符遍历，可以直接遍历中文
嵌套循环最好不要超过三层
goto不建议使用，容易造成程序的混乱


--------包的调用----------
import ("xxx")//包名
xxx.Cal()//包中函数的调用，函数名要大写才可以跨包调用

函数可以赋给一个变量使用
函数也可以作为形参使用
函数也可以作为一个数据类型存在
函数的返回值可以命名
函数的参数可以是可变的，slice并且是放在最后的参数.
初始化函数init；全局变量定义->init函数->main函数；如果有加载包那就先执行加载包的变量、init函数


匿名函数
res := func(n1,n2 int) int{ return n1+n2}(10,20)//匿名函数的定义并赋值
a := func(n1,n2 int) int{return n1 - n2}    a(10,20)//把匿名函数赋给一个变量
var (Fun := func(n1,n2 int) int{return n1*n2}) //匿名函数也可以赋给一个全局变量

闭包函数
匿名函数和使用到的函数体外的变量会形成一个引用关系，形成一个闭包整体，被引用的变量只初始化一次

函数参数的传递方式
值传递：基本数据类型int,float,bool,string,数组,struct
引用传递：指针，切片slice，map，interface,chan管道

----------------数组，索引数组-----------------
1、数组的下标是从0开始的
2、数组的值类型必须保持一致
3、数组的调用，长度必须保持一致
4、数组的首地址既是数组的地址，每个索引值地址差8个字节
5、数组的长度是固定的，定义时即固定


--------切片slice------
1、引用数组的值，数组可见，值会跟着slice改变，slice的容量是截取数组的第一个值到最后一个值的个数，存在长度越界的问题，值不包括最后一个索引的值
2、make创建slice也会创建一个数组，但是该数组在底层维护，不可见，make可以规定slice的长度和容量
3、slice可以动态增加，append(slice,value,value)数据类型要保持一致，切片也可以追加切片
4、copy切片的拷贝，只能是切片之间的copy,长度不一致不会报错可以正常copy
5、切片在函数传递的时候也是引用类型
6、string也可以切片处理,但是不可以通过切片修改原有值，可以先转为byte或rune切片然后再转回string

-------map,对象、关联数组、映射，无序的----------
1、声明是不分配内存，只有在make初始化以后才会分配内存
2、使用方式，
 1）先申明，再make，var m map[string] string m=make(map[string]string);
 2）直接make初始化，var m = make(map[string]string,10);长度可以去掉
 3）直接初始化并赋值，可以舍弃make,var m = map[string]string{"name":"xiong"}
3、map是引用类型。
4、map的长度能动态增长


--------struct结构体-----------
1、面向对象中的类，具有封装、继承、多态性,值类型
2、定义结构体type funcName struct{}
